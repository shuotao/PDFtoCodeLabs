# Google Prompt Engineering Codelabs å°ˆæ¡ˆå ±å‘Š

## ğŸ“ å°ˆæ¡ˆæª”æ¡ˆæ¸…å–®

### ç¶²é æª”æ¡ˆ
| æª”æ¡ˆåç¨± | èªªæ˜ | å¤§å° |
|----------|------|------|
| `Google_Prompting_Codelabs_Part1.html` | äº’å‹•å¼ Codelabs æ•™å­¸ç¶²é ï¼ˆ11 ç« ç¯€ï¼‰ | 163 KB |

### åœ–ç‰‡è³‡æ–™å¤¾ (`images/`)
å…± 25 å¼µ Gemini ç•Œé¢æˆªåœ–ï¼š

| æª”æ¡ˆåç¨± | ç« ç¯€ | å…§å®¹æè¿° |
|----------|------|----------|
| page7_img1.jpeg | Ch 2 | è¡Œæ”¿æ”¯æ´ - ç•°åœ°æœƒè­°è­°ç¨‹ |
| page8_img1.jpeg | Ch 2 | ç ´å†°æ´»å‹•å»ºè­° |
| page8_img2.jpeg | Ch 2 | è¡¨æ ¼æ ¼å¼è­°ç¨‹ |
| page9_img1.jpeg | Ch 2 | è­°ç¨‹è©³ç´°å…§å®¹ |
| page13_img1.jpeg | Ch 3 | æ–°èç¨¿åˆå§‹å›æ‡‰ |
| page13_img3.jpeg | Ch 3 | æ–°èç¨¿è¿­ä»£å›æ‡‰ï¼ˆå…¬å¸è³‡è¨Šï¼‰|
| page18_img1.jpeg | Ch 4 | åŒç†å¿ƒé›»å­éƒµä»¶å›æ‡‰ |
| page18_img4.jpeg | Ch 4 | 10 å€‹æ›¿ä»£æ–¹æ¡ˆåˆ—è¡¨ |
| page24_img1.jpeg | Ch 5 | ç¢ºèªéƒµä»¶ç²¾ç…‰å¾Œç‰ˆæœ¬ |
| page24_img3.jpeg | Ch 5 | ç¢ºèªéƒµä»¶åˆå§‹å›æ‡‰ |
| page33_img1.jpeg | Ch 6 | Gemini in Drive æœå°‹çµæœ |
| page34_img1.jpeg | Ch 6 | ä¿ƒéŠ·æŠ˜æ‰£æŸ¥è©¢å›æ‡‰ |
| page34_img2.jpeg | Ch 6 | ä¿ƒéŠ·è©³æƒ… |
| page39_img1.jpeg | Ch 7 | HR æ¼”è¬›è¦é»åˆå§‹å›æ‡‰ |
| page39_img2.jpeg | Ch 7 | HR æ¼”è¬›è¦é»è¿­ä»£å›æ‡‰ |
| page45_img1.jpeg | Ch 8 | å’–å•¡åº—æ¨™èªŒå‰µæ„ |
| page45_img2.jpeg | Ch 8 | å¾©å¤é¢¨æ ¼æ¨™èªŒ |
| page45_img3.jpeg | Ch 8 | æ¥­å‹™åç¨±å’Œæ¨™èªå»ºè­° |
| page55_img1.jpeg | Ch 9 | UAT è¡¨æ ¼ç”Ÿæˆ |
| page56_img1.jpeg | Ch 9 | UAT é›»å­éƒµä»¶è‰ç¨¿ |
| page56_img4.jpeg | Ch 9 | UAT é›»å­éƒµä»¶è©³ç´°å…§å®¹ |
| page61_img1.jpeg | Ch 10 | éŠ·å”®éƒµä»¶ç²¾ç…‰å¾Œç‰ˆæœ¬ |
| page61_img2.jpeg | Ch 10 | éŠ·å”®éƒµä»¶åˆå§‹å›æ‡‰ |
| page62_img1.jpeg | Ch 10 | å¸‚å ´ç­–ç•¥ç ”ç©¶å›æ‡‰ |
| page70_img1.jpeg | Ch 11 | å…­å¤§æŠ€å·§è¦–è¦ºåŒ–åœ–è¡¨ |

### åŸå§‹åƒè€ƒè³‡æ–™
| æª”æ¡ˆåç¨± | èªªæ˜ |
|----------|------|
| `Google's 71-page prompting guide.pdf` | åŸå§‹ PDFï¼ˆ71 é ï¼‰|
| `Google_Prompting_Guide.md` | Markitdown è½‰æ›çš„ Markdown |
| `2025-01-18-pdf-1-TechAI-Goolge-whitepaper_Prompt Engineering_v4-af36dcc7a49bb7269a58b1c9b89a8ae1 (1).pdf` | åŸå§‹ä¸Šå‚³ PDF |

### å·¥å…·è³‡æ–™å¤¾
| è³‡æ–™å¤¾ | èªªæ˜ |
|--------|------|
| `markitdown/` | Microsoft Markitdown å·¥å…·ï¼ˆGitHub cloneï¼‰|

---

## ğŸ”§ Markitdown å•é¡Œåˆ†æèˆ‡ä¿®æ­£å»ºè­°

### å•é¡Œä¸€ï¼šPDF é¡è‰²æ–‡å­—ç„¡æ³•è­˜åˆ¥

**å•é¡Œæè¿°**ï¼š
PDF ä¸­ä½¿ç”¨é¡è‰²æ¨™è¨˜çš„æç¤ºè©å…ƒç´ ï¼ˆPersona=ç´…è‰²ã€Task=è—è‰²ã€Context=ç¶ è‰²ã€Format=é»ƒè‰²ï¼‰åœ¨è½‰æ›æ™‚æœƒä¸Ÿå¤±é¡è‰²è³‡è¨Šã€‚

**æ ¹æœ¬åŸå› **ï¼š
`_pdf_converter.py` ä½¿ç”¨ pdfminer å’Œ pdfplumber æå–æ–‡å­—ï¼Œé€™äº›å·¥å…·åªæå–ç´”æ–‡å­—å…§å®¹ï¼Œä¸ä¿ç•™å­—é«”é¡è‰²å±¬æ€§ã€‚

**ä¿®æ­£å»ºè­°**ï¼š
```python
# åœ¨ _pdf_converter.py ä¸­æ·»åŠ é¡è‰²æå–åŠŸèƒ½
import fitz  # PyMuPDF

def extract_colored_text(pdf_path):
    """æå– PDF ä¸­å¸¶æœ‰é¡è‰²è³‡è¨Šçš„æ–‡å­—"""
    doc = fitz.open(pdf_path)
    colored_spans = []
    
    for page in doc:
        blocks = page.get_text("dict")["blocks"]
        for block in blocks:
            if "lines" in block:
                for line in block["lines"]:
                    for span in line["spans"]:
                        color = span.get("color", 0)
                        if color != 0:  # éé»‘è‰²æ–‡å­—
                            colored_spans.append({
                                "text": span["text"],
                                "color": color,
                                "page": page.number
                            })
    return colored_spans
```

**é¡è‰²å°æ‡‰è¡¨**ï¼š
| é¡è‰²ä»£ç¢¼ | å…ƒç´ é¡å‹ | HTML Class |
|----------|----------|------------|
| 0xE74C3C | Persona | tag-persona |
| 0x3498DB | Task | tag-task |
| 0x27AE60 | Context | tag-context |
| 0xF1C40F | Format | tag-format |

---

### å•é¡ŒäºŒï¼šPDF åœ–ç‰‡æå–è—è‰²æ¢ç´‹å•é¡Œ

**å•é¡Œæè¿°**ï¼š
æå–çš„åœ–ç‰‡ä¸­æœ‰ 11 å¼µæ˜¯ç›¸åŒçš„è—è‰²æ¼¸è®Šæ¢ç´‹ï¼ˆ255,194 bytesï¼‰ï¼Œè€Œéå¯¦éš›çš„ Gemini æˆªåœ–ã€‚

**æ ¹æœ¬åŸå› **ï¼š
1. PDF ä¸­çš„è—è‰²æ¢ç´‹æ˜¯è£é£¾æ€§èƒŒæ™¯å…ƒç´ ï¼Œè¢«ç•¶ä½œåœ–ç‰‡æå–
2. Markitdown çš„ `_image_converter.py` æ²’æœ‰éæ¿¾æ©Ÿåˆ¶
3. PDF ä¸­çš„ Gemini æˆªåœ–å¯èƒ½ä½¿ç”¨å‘é‡åœ–å½¢æˆ–åµŒå…¥æ–¹å¼ä¸åŒ

**ä¿®æ­£å»ºè­°**ï¼š
```python
# åœ¨åœ–ç‰‡æå–é‚è¼¯ä¸­æ·»åŠ éæ¿¾
def is_decorative_image(image_bytes, width, height):
    """åˆ¤æ–·æ˜¯å¦ç‚ºè£é£¾æ€§åœ–ç‰‡"""
    # éæ¿¾æ¢ä»¶ï¼š
    # 1. åœ–ç‰‡å°ºå¯¸éæ–¼ç´°é•·ï¼ˆé«˜åº¦/å¯¬åº¦æ¯” < 0.3ï¼‰
    # 2. åœ–ç‰‡å¤§å°å®Œå…¨ç›¸åŒï¼ˆ255194 bytes = è£é£¾æ¢ç´‹ï¼‰
    # 3. åœ–ç‰‡å…§å®¹é‡è¤‡å‡ºç¾å¤šæ¬¡
    
    if height / width < 0.3:  # ç´°é•·æ¢ç´‹
        return True
    if len(image_bytes) == 255194:  # å·²çŸ¥çš„è£é£¾æ¢ç´‹å¤§å°
        return True
    return False

# ä½¿ç”¨ PyMuPDF æå–åœ–ç‰‡æ™‚éæ¿¾
def extract_meaningful_images(pdf_path, output_dir):
    doc = fitz.open(pdf_path)
    seen_hashes = set()
    
    for page_num, page in enumerate(doc):
        for img_index, img in enumerate(page.get_images(full=True)):
            xref = img[0]
            base_image = doc.extract_image(xref)
            image_bytes = base_image["image"]
            
            # è¨ˆç®—åœ–ç‰‡å“ˆå¸Œå€¼ï¼Œéæ¿¾é‡è¤‡
            img_hash = hashlib.md5(image_bytes).hexdigest()
            if img_hash in seen_hashes:
                continue
            seen_hashes.add(img_hash)
            
            # éæ¿¾è£é£¾æ€§åœ–ç‰‡
            if len(image_bytes) == 255194:
                continue
                
            # ä¿å­˜æœ‰æ„ç¾©çš„åœ–ç‰‡
            # ...
```

---

## ğŸ“Š å°ˆæ¡ˆçµ±è¨ˆ

| é …ç›® | æ•¸é‡ |
|------|------|
| ç« ç¯€æ•¸ | 11 |
| ç¸½æç¤ºè©æ•¸ | 132 |
| æœ‰é¡è‰²æ¨™ç±¤çš„æç¤ºè© | 10 |
| ä½¿ç”¨çš„åœ–ç‰‡æ•¸ | 25 |
| HTML æª”æ¡ˆå¤§å° | 163 KB |

---

## âœ… å·²å®Œæˆçš„ä¿®æ­£

1. **åœ–ç‰‡è³‡æ–™å¤¾æ•´ç†**ï¼šç§»é™¤è—è‰²æ¢ç´‹è£é£¾åœ–ç‰‡ï¼Œåªä¿ç•™ 25 å¼µæœ‰æ•ˆæˆªåœ–
2. **åœ–ç‰‡é‡è¤‡å•é¡Œ**ï¼šä¿®æ­£ Ch 3ã€4ã€5ã€7ã€10 çš„é‡è¤‡åœ–ç‰‡å¼•ç”¨
3. **æç¤ºè©æ¨™ç±¤ä¿®æ­£**ï¼šä¿®æ­£ Ch 3ã€5ã€6ã€7ã€9ã€10 çš„é¡è‰²æ¨™ç±¤éŒ¯èª¤
4. **æª”æ¡ˆæ¸…ç†**ï¼šç§»é™¤è‡¨æ™‚è…³æœ¬å’Œä¸­é–“æª”æ¡ˆ

---

*å ±å‘Šç”Ÿæˆæ™‚é–“ï¼š2026-02-04*
